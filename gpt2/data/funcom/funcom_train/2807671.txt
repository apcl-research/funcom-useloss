TDAT: public list match and assemble ( list in ) {  <NL> list out = match ( in ) ;  <NL>  <NL>  / / if ( debug . verbose on ( ) ) debug . log verbose ( " [ match and assemble ] after match , before assemble : in = " + in + " , out = " + out , module ) ;  <NL>  <NL> if ( assembler ! = null ) {  <NL> enumeration e = collections . enumeration ( out ) ;  <NL>  <NL> while ( e . has more elements ( ) ) {  <NL> assembler . work on ( ( assembly ) e . next element ( ) ) ;  <NL>  }  <NL>  }  <NL> return out ;  <NL>  }  COM: <s> match this parser against an input state and then </s>