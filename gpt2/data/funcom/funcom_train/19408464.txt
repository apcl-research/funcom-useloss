TDAT: public list navigable ends from ( m class cls ) {  <NL> list res = new array list ( ) ;  <NL> boolean part of assoc = false ;  <NL> iterator it = f association ends . iterator ( ) ;  <NL> while ( it . has next ( ) ) {  <NL> m association end aend = ( m association end ) it . next ( ) ;  <NL> if ( ! aend . cls ( ) . equals ( cls ) )  <NL> res . add ( aend ) ;  <NL> else {  <NL> part of assoc = true ;  <NL> if ( f is reflexive )  <NL> res . add ( aend ) ;  <NL>  }  <NL>  }  <NL> if ( ! part of assoc )  <NL> throw new illegal argument exception ( " class ` " + cls . name ( )  <NL>  + " ' is not part of this association . " ) ;  <NL> return res ;  <NL>  }  COM: <s> returns a list of association ends which can be reached by navigation </s>